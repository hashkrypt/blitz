function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import { AbiCoder } from 'ethers';
import { isHexString, UINT_160_MAX, UINT_256_MAX } from '@1inch/byte-utils';
import assert from 'assert';
import { buildOrderTypedData, getLimitOrderV4Domain, getOrderHash } from './eip712/index.js';
import { MakerTraits } from './maker-traits.js';
import { Extension } from './extensions/extension.js';
import { injectTrackCode } from './source-track.js';
import { Address } from '../address.js';
import { randBigInt } from '../utils/rand-bigint.js';
export var LimitOrder = /*#__PURE__*/ function() {
    "use strict";
    function LimitOrder(orderInfo) {
        var makerTraits = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new MakerTraits(0n), extension = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Extension.default();
        _class_call_check(this, LimitOrder);
        var _orderInfo_receiver;
        _define_property(this, "extension", void 0);
        _define_property(this, "maker", void 0);
        _define_property(this, "receiver", void 0);
        _define_property(this, "makerAsset", void 0);
        _define_property(this, "takerAsset", void 0);
        _define_property(this, "makingAmount", void 0);
        _define_property(this, "takingAmount", void 0);
        _define_property(this, "makerTraits", void 0);
        _define_property(this, "_salt", void 0);
        this.extension = extension;
        assert(!orderInfo.takerAsset.isNative(), "".concat(orderInfo.takerAsset, " can not be 'takerAsset'. Use wrapper address as 'takerAsset' and 'makerTraits.enableNativeUnwrap' to swap to NATIVE currency"));
        assert(!orderInfo.makerAsset.isNative(), 'Maker asset can not be NATIVE, use wrapper');
        this.makerAsset = orderInfo.makerAsset;
        this.takerAsset = orderInfo.takerAsset;
        this.makingAmount = orderInfo.makingAmount;
        this.takingAmount = orderInfo.takingAmount;
        this._salt = LimitOrder.verifySalt(orderInfo.salt || LimitOrder.buildSalt(extension), extension);
        this.maker = orderInfo.maker;
        this.receiver = ((_orderInfo_receiver = orderInfo.receiver) === null || _orderInfo_receiver === void 0 ? void 0 : _orderInfo_receiver.equal(orderInfo.maker)) ? Address.ZERO_ADDRESS : orderInfo.receiver || Address.ZERO_ADDRESS;
        this.makerTraits = makerTraits;
        assert(this.makingAmount <= UINT_256_MAX, 'makingAmount too big');
        assert(this.takingAmount <= UINT_256_MAX, 'takingAmount too big');
        if (!extension.isEmpty()) {
            this.makerTraits.withExtension();
        }
    }
    _create_class(LimitOrder, [
        {
            key: "salt",
            get: function get() {
                return this._salt;
            }
        },
        {
            key: "setSource",
            value: /**
     * Injects source info to order `salt` [224, 255] bits
     * check `getTrackCodeForSource` implementation for exact injected data
     *
     * @param source order source identifier
     * @see getTrackCodeForSource
     */ function setSource(source) {
                this._salt = injectTrackCode(this.salt, source);
                return this;
            }
        },
        {
            key: "toCalldata",
            value: function toCalldata() {
                return AbiCoder.defaultAbiCoder().encode([
                    LimitOrder.Web3Type
                ], [
                    this.build()
                ]);
            }
        },
        {
            key: "build",
            value: function build() {
                var _this_makerTraits;
                return {
                    maker: this.maker.toString(),
                    makerAsset: this.makerAsset.toString(),
                    takerAsset: this.takerAsset.toString(),
                    makerTraits: (((_this_makerTraits = this.makerTraits) === null || _this_makerTraits === void 0 ? void 0 : _this_makerTraits.asBigInt()) || 0n).toString(),
                    salt: this.salt.toString(),
                    makingAmount: this.makingAmount.toString(),
                    takingAmount: this.takingAmount.toString(),
                    receiver: this.receiver.toString()
                };
            }
        },
        {
            key: "getTypedData",
            value: function getTypedData(chainId) {
                var domain = getLimitOrderV4Domain(chainId);
                return buildOrderTypedData(domain.chainId, domain.verifyingContract, domain.name, domain.version, this.build());
            }
        },
        {
            key: "getOrderHash",
            value: function getOrderHash1(chainId) {
                return getOrderHash(this.getTypedData(chainId));
            }
        },
        {
            key: "isPrivate",
            value: /**
     * Returns true if only a specific address can fill order
     */ function isPrivate() {
                return this.makerTraits.isPrivate();
            }
        }
    ], [
        {
            key: "buildSalt",
            value: /**
     * Build correct salt for order
     *
     * If order has extension - it is crucial to build correct salt
     * otherwise order won't be ever filled
     *
     * @see https://github.com/1inch/limit-order-protocol/blob/7bc5129ae19832338169ca21e4cf6331e8ff44f6/contracts/OrderLib.sol#L153
     *
     */ function buildSalt(extension) {
                var baseSalt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : randBigInt((1n << 96n) - 1n);
                if (extension.isEmpty()) {
                    return baseSalt;
                }
                return baseSalt << 160n | extension.keccak256() & UINT_160_MAX;
            }
        },
        {
            key: "verifySalt",
            value: function verifySalt(salt, extension) {
                assert(salt <= UINT_256_MAX, 'salt too big');
                if (extension.isEmpty()) {
                    return salt;
                }
                var hash = salt & UINT_160_MAX;
                var expectedHash = extension.keccak256() & UINT_160_MAX;
                assert(hash === expectedHash, 'invalid salt: lowest 160 bits should be extension hash');
                return salt;
            }
        },
        {
            key: "fromCalldata",
            value: function fromCalldata(bytes) {
                assert(isHexString(bytes), 'Bytes should be valid hex string with 0x prefix');
                var info = AbiCoder.defaultAbiCoder().decode([
                    LimitOrder.Web3Type
                ], bytes);
                var order = info[0];
                return new LimitOrder({
                    salt: order.salt ? BigInt(order.salt) : undefined,
                    maker: new Address(order.maker),
                    receiver: new Address(order.receiver),
                    takingAmount: BigInt(order.takingAmount),
                    makingAmount: BigInt(order.makingAmount),
                    takerAsset: new Address(order.takerAsset),
                    makerAsset: new Address(order.makerAsset)
                }, new MakerTraits(BigInt(order.makerTraits)));
            }
        },
        {
            key: "fromDataAndExtension",
            value: function fromDataAndExtension(data, extension) {
                return new LimitOrder({
                    salt: BigInt(data.salt),
                    maker: new Address(data.maker),
                    receiver: new Address(data.receiver),
                    takingAmount: BigInt(data.takingAmount),
                    makingAmount: BigInt(data.makingAmount),
                    takerAsset: new Address(data.takerAsset),
                    makerAsset: new Address(data.makerAsset)
                }, new MakerTraits(BigInt(data.makerTraits)), extension);
            }
        }
    ]);
    return LimitOrder;
}();
_define_property(LimitOrder, "Web3Type", "tuple(".concat([
    'uint256 salt',
    'address maker',
    'address receiver',
    'address makerAsset',
    'address takerAsset',
    'uint256 makingAmount',
    'uint256 takingAmount',
    'uint256 makerTraits'
], ")"));
