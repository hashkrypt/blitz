"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "FeeTakerExtension", {
    enumerable: true,
    get: function() {
        return FeeTakerExtension;
    }
});
var _byteutils = require("@1inch/byte-utils");
var _assert = /*#__PURE__*/ _interop_require_default(require("assert"));
var _fees = require("./fees.js");
var _resolverfee = require("./resolver-fee.js");
var _integratorfee = require("./integrator-fee.js");
var _whitelisthalfaddress = require("./whitelist-half-address.js");
var _feecalculator = require("./fee-calculator.js");
var _extensionbuilder = require("../extension-builder.js");
var _address = require("../../../address.js");
var _interaction = require("../../interaction.js");
var _extension = require("../extension.js");
var _bps = require("../../../bps.js");
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * @see https://github.com/1inch/limit-order-protocol/blob/master/contracts/extensions/FeeTaker.sol
 */ var FeeTakerExtension = /*#__PURE__*/ function() {
    "use strict";
    function FeeTakerExtension(address, fees, whitelist, makerPermit, extraInteraction, customReceiver) {
        _class_call_check(this, FeeTakerExtension);
        _define_property(this, "address", void 0);
        _define_property(this, "fees", void 0);
        _define_property(this, "whitelist", void 0);
        _define_property(this, "makerPermit", void 0);
        _define_property(this, "extraInteraction", void 0);
        _define_property(this, "customReceiver", void 0);
        this.address = address;
        this.fees = fees;
        this.whitelist = whitelist;
        this.makerPermit = makerPermit;
        this.extraInteraction = extraInteraction;
        this.customReceiver = customReceiver;
    }
    _create_class(FeeTakerExtension, [
        {
            key: "getFeeCalculator",
            value: function getFeeCalculator() {
                return new _feecalculator.FeeCalculator(this.fees, this.whitelist);
            }
        },
        {
            key: "build",
            value: function build() {
                var amountGetterData = this.buildAmountGetterData();
                var builder = new _extensionbuilder.ExtensionBuilder().withMakingAmountData(this.address, amountGetterData).withTakingAmountData(this.address, amountGetterData).withPostInteraction(new _interaction.Interaction(this.address, this.buildInteractionData()));
                if (this.makerPermit) {
                    builder.withMakerPermit(this.makerPermit.target, this.makerPermit.data);
                }
                return builder.build();
            }
        },
        {
            key: "getTakingAmount",
            value: /**
     * Returns takingAmount with applied fees to it
     *
     * @param taker address which fill order
     * @param takingAmount amount to apply fee to
     */ function getTakingAmount(taker, takingAmount) {
                return this.getFeeCalculator().getTakingAmount(taker, takingAmount);
            }
        },
        {
            key: "getMakingAmount",
            value: /**
     * Returns makingAmount with applied fees to it
     *
     * @param taker address which fill order
     * @param makingAmount amount to apply fee to
     */ function getMakingAmount(taker, makingAmount) {
                return this.getFeeCalculator().getMakingAmount(taker, makingAmount);
            }
        },
        {
            key: "getResolverFee",
            value: /**
     * Fee in `takerAsset` which resolver pays to resolver fee receiver
     *
     * @param taker who will fill order
     * @param takingAmount taking amount to apply fee to
     */ function getResolverFee(taker, takingAmount) {
                return this.getFeeCalculator().getResolverFee(taker, takingAmount);
            }
        },
        {
            key: "getIntegratorFee",
            value: /**
     * Fee in `takerAsset` which integrator gets to integrator wallet
     *
     * @param taker who will fill order
     * @param takingAmount taking amount to calculate fee from
     */ function getIntegratorFee(taker, takingAmount) {
                return this.getFeeCalculator().getIntegratorFee(taker, takingAmount);
            }
        },
        {
            key: "getProtocolShareOfIntegratorFee",
            value: /**
     * Fee in `takerAsset` which protocol gets as share from integrator fee
     *
     * @param taker who will fill order
     * @param takingAmount taking amount to calculate fee from
     */ function getProtocolShareOfIntegratorFee(taker, takingAmount) {
                return this.getFeeCalculator().getProtocolShareOfIntegratorFee(taker, takingAmount);
            }
        },
        {
            key: "getProtocolFee",
            value: /**
     * Fee in `takerAsset` which protocol gets
     * It equals to `share from integrator fee plus resolver fee`
     *
     * @param taker who will fill order
     * @param takingAmount taking amount to calculate fee from
     */ function getProtocolFee(taker, takingAmount) {
                return this.getFeeCalculator().getProtocolFee(taker, takingAmount);
            }
        },
        {
            key: "buildAmountGetterData",
            value: /**
     * Build data for AmountGetterWithFee
     *
     * 2 bytes — integrator fee percentage (in 1e5)
     * 1 byte - integrator share percentage (in 1e2)
     * 2 bytes — resolver fee percentage (in 1e5)
     * 1 byte - whitelist discount numerator (in 1e2)
     * 1 byte - size of the whitelist
     * (bytes10)[N] whitelisted addresses;
     *
     * @see https://github.com/1inch/limit-order-protocol/blob/22a18f7f20acfec69d4f50ce1880e8e662477710/contracts/extensions/AmountGetterWithFee.sol#L56
     */ function buildAmountGetterData() {
                var integrator = {
                    fee: this.fees.integrator.fee.toFraction(_fees.Fees.BASE_1E5),
                    share: this.fees.integrator.share.toFraction(_fees.Fees.BASE_1E2)
                };
                var resolverFee = this.fees.resolver.fee.toFraction(_fees.Fees.BASE_1E5);
                var builder = new _byteutils.BytesBuilder().addUint16(BigInt(integrator.fee)).addUint8(BigInt(integrator.share)).addUint16(BigInt(resolverFee)).addUint8(BigInt(// contract expects discount numerator, but class contain discount
                Number(_fees.Fees.BASE_1E2) - this.fees.resolver.whitelistDiscount.toFraction(_fees.Fees.BASE_1E2)));
                this.whitelist.encodeTo(builder);
                return builder.asHex();
            }
        },
        {
            key: "buildInteractionData",
            value: /**
     * Build data for `FeeTaker.postInteraction`
     *
     *
     * 1 byte - flags:
     *      01 bit `CUSTOM_RECEIVER_FLAG` - set to 1 if order has custom receiver
     * 20 bytes — integrator fee recipient
     * 20 bytes - protocol fee recipient
     * [20 bytes] — receiver of taking tokens (optional, if not set, maker is used). See `CUSTOM_RECEIVER_FLAG` flag
     * Same as in `buildAmountGetterData`
     * [bytes20, bytes] - optional extra interaction
     * @see buildAmountGetterData
     * @see https://github.com/1inch/limit-order-protocol/blob/22a18f7f20acfec69d4f50ce1880e8e662477710/contracts/extensions/FeeTaker.sol#L114
     */ function buildInteractionData() {
                var flags = new _byteutils.BN(0n).setBit(FeeTakerExtension.CUSTOM_RECEIVER_FLAG_BIT, Boolean(this.customReceiver));
                var builder = new _byteutils.BytesBuilder().addUint8(flags).addAddress(this.fees.integrator.integrator.toString()).addAddress(this.fees.protocol.toString());
                if (this.customReceiver) {
                    builder.addAddress(this.customReceiver.toString());
                }
                builder.addBytes(this.buildAmountGetterData());
                if (this.extraInteraction) {
                    builder.addAddress(this.extraInteraction.target.toString()).addBytes(this.extraInteraction.data);
                }
                return builder.asHex();
            }
        }
    ], [
        {
            key: "new",
            value: function _new(/**
         * Address of extension
         */ address, /**
         * @see ResolverFee
         * @see IntegratorFee
         */ fees, /**
         * If empty, then KYC token is required to fill order
         */ whitelist, extra) /**
             * In case receiver of taker tokens is not maker
             */ /**
             * Will be called after FeeTaker.postInteraction
             */ {
                return new FeeTakerExtension(address, fees, _whitelisthalfaddress.WhitelistHalfAddress.new(whitelist || []), extra === null || extra === void 0 ? void 0 : extra.makerPermit, extra === null || extra === void 0 ? void 0 : extra.extraInteraction, extra === null || extra === void 0 ? void 0 : extra.customReceiver);
            }
        },
        {
            key: "decode",
            value: /**
     * Create `FeeTakerExtension` from bytes
     *
     * @param bytes 0x prefixed bytes
     */ function decode(bytes) {
                var extension = _extension.Extension.decode(bytes);
                return FeeTakerExtension.fromExtension(extension);
            }
        },
        {
            key: "fromExtension",
            value: /**
     * Create `FeeTakerExtension` from `Extension`
     */ function fromExtension(extension) {
                var extensionAddress = _address.Address.fromFirstBytes(extension.makingAmountData);
                (0, _assert.default)(_address.Address.fromFirstBytes(extension.takingAmountData).equal(extensionAddress) && _address.Address.fromFirstBytes(extension.postInteraction).equal(extensionAddress), 'Invalid extension, all calls should be to the same address');
                (0, _assert.default)(extension.takingAmountData == extension.makingAmountData, 'Invalid extension, taking amount data must be equal to making amount data');
                // region Parse postInteraction data
                var interactionBytes = _byteutils.BytesIter.HexString(extension.postInteraction);
                interactionBytes.nextUint160();
                // skip address of extension
                var flags = _byteutils.BN.fromHex(interactionBytes.nextUint8());
                var integratorFeeRecipient = new _address.Address(interactionBytes.nextUint160());
                var protocolFeeRecipient = new _address.Address(interactionBytes.nextUint160());
                var customTokensRecipient = flags.getBit(FeeTakerExtension.CUSTOM_RECEIVER_FLAG_BIT) ? new _address.Address(interactionBytes.nextUint160()) : undefined;
                var interactionData = parseAmountData(interactionBytes);
                var extraInteraction = interactionBytes.isEmpty() ? undefined : _interaction.Interaction.decode(interactionBytes.rest());
                //endregion Parse postInteraction data
                //region Parse amount data
                var amountBytes = _byteutils.BytesIter.HexString(extension.makingAmountData);
                amountBytes.nextUint160();
                // skip address of extension
                var amountData = parseAmountData(amountBytes);
                //endregion Parse amount data
                var permit = extension.hasMakerPermit ? _interaction.Interaction.decode(extension.makerPermit) : undefined;
                (0, _assert.default)(amountData.fees.integratorFee.value === interactionData.fees.integratorFee.value, "invalid extension: integrator fee must be same in interaction data and in amount data");
                (0, _assert.default)(amountData.fees.resolverFee.value === interactionData.fees.resolverFee.value, "invalid extension: resolver fee must be same in interaction data and in amount data");
                (0, _assert.default)(amountData.whitelist.discount.value === interactionData.whitelist.discount.value, "invalid extension: whitelist discount fee must be same in interaction data and in amount data");
                (0, _assert.default)(amountData.fees.integratorShare.value === interactionData.fees.integratorShare.value, "invalid extension: integrator share must be same in interaction data and in amount data");
                (0, _assert.default)(interactionData.whitelist.addresses.length === amountData.whitelist.addresses.length, 'whitelist must be same in interaction data and in amount data');
                (0, _assert.default)(interactionData.whitelist.addresses.every(function(val, i) {
                    return amountData.whitelist.addresses[i] === val;
                }), 'whitelist must be same in interaction data and in amount data');
                return new FeeTakerExtension(extensionAddress, new _fees.Fees(amountData.fees.resolverFee.isZero() ? _resolverfee.ResolverFee.ZERO : new _resolverfee.ResolverFee(protocolFeeRecipient, amountData.fees.resolverFee, amountData.whitelist.discount), amountData.fees.integratorFee.isZero() ? _integratorfee.IntegratorFee.ZERO : new _integratorfee.IntegratorFee(integratorFeeRecipient, protocolFeeRecipient, amountData.fees.integratorFee, amountData.fees.integratorShare)), new _whitelisthalfaddress.WhitelistHalfAddress(amountData.whitelist.addresses), permit, extraInteraction, customTokensRecipient);
            }
        }
    ]);
    return FeeTakerExtension;
}();
/**
     * Flags for post-interaction data
     * @private
     */ _define_property(FeeTakerExtension, "CUSTOM_RECEIVER_FLAG_BIT", 0n);
function parseAmountData(iter) {
    var fees = {
        integratorFee: _bps.Bps.fromFraction(Number(iter.nextUint16()), _fees.Fees.BASE_1E5),
        integratorShare: _bps.Bps.fromFraction(Number(iter.nextUint8()), _fees.Fees.BASE_1E2),
        resolverFee: _bps.Bps.fromFraction(Number(iter.nextUint16()), _fees.Fees.BASE_1E5)
    };
    var whitelistDiscount = _bps.Bps.fromFraction(Number(_fees.Fees.BASE_1E2) - Number(iter.nextUint8()), // contract uses 1 - discount
    _fees.Fees.BASE_1E2);
    var whitelistAddresses = [];
    var whitelistFromAmountSize = Number(iter.nextUint8());
    for(var i = 0; i < whitelistFromAmountSize; i++){
        whitelistAddresses.push(iter.nextBytes(10));
    }
    return {
        fees: fees,
        whitelist: {
            discount: whitelistDiscount,
            addresses: whitelistAddresses
        }
    };
}
