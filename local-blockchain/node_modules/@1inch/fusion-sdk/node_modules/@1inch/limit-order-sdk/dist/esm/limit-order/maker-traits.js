function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import { add0x, BitMask, BN } from '@1inch/byte-utils';
import assert from 'assert';
/**
 * The MakerTraits type is an uint256, and different parts of the number are used to encode different traits.
 * High bits are used for flags
 * 255 bit `NO_PARTIAL_FILLS_FLAG`          - if set, the order does not allow partial fills
 * 254 bit `ALLOW_MULTIPLE_FILLS_FLAG`      - if set, the order permits multiple fills
 * 253 bit                                  - unused
 * 252 bit `PRE_INTERACTION_CALL_FLAG`      - if set, the order requires pre-interaction call
 * 251 bit `POST_INTERACTION_CALL_FLAG`     - if set, the order requires post-interaction call
 * 250 bit `NEED_CHECK_EPOCH_MANAGER_FLAG`  - if set, the order requires to check the epoch manager
 * 249 bit `HAS_EXTENSION_FLAG`             - if set, the order has extension(s)
 * 248 bit `USE_PERMIT2_FLAG`               - if set, the order uses permit2
 * 247 bit `UNWRAP_WETH_FLAG`               - if set, the order requires to unwrap WETH
 *
 * Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series
 * uint80 last 10 bytes of allowed sender address (0 if any)
 * uint40 expiration timestamp (0 if none)
 * uint40 nonce or epoch
 * uint40 series
 */ export var MakerTraits = /*#__PURE__*/ function() {
    "use strict";
    function MakerTraits(val) {
        _class_call_check(this, MakerTraits);
        _define_property(this, "value", void 0);
        this.value = new BN(val);
    }
    _create_class(MakerTraits, [
        {
            key: "allowedSender",
            value: /**
     * Last 10bytes of address
     */ function allowedSender() {
                return this.value.getMask(MakerTraits.ALLOWED_SENDER_MASK).value.toString(16).padStart(20, '0');
            }
        },
        {
            key: "isPrivate",
            value: function isPrivate() {
                return this.value.getMask(MakerTraits.ALLOWED_SENDER_MASK).value !== 0n;
            }
        },
        {
            key: "withAllowedSender",
            value: function withAllowedSender(sender) {
                assert(!sender.isZero(), 'Use withAnySender() to remove sender check');
                var lastHalf = add0x(sender.toString().slice(-20));
                this.value = this.value.setMask(MakerTraits.ALLOWED_SENDER_MASK, BigInt(lastHalf));
                return this;
            }
        },
        {
            key: "withAnySender",
            value: /**
     * Removes `sender` check on contract
     */ function withAnySender() {
                this.value = this.value.setMask(MakerTraits.ALLOWED_SENDER_MASK, BigInt(0));
                return this;
            }
        },
        {
            key: "expiration",
            value: /**
     * If null is return than order has no expiration
     */ function expiration() {
                var timestampSec = this.value.getMask(MakerTraits.EXPIRATION_MASK);
                if (timestampSec.isZero()) {
                    return null;
                }
                return timestampSec.value;
            }
        },
        {
            key: "withExpiration",
            value: /**
     * Set order expiration time
     *
     * @param expiration expiration timestamp in sec
     */ function withExpiration(expiration) {
                var expirationSec = expiration === null ? 0n : expiration;
                this.value = this.value.setMask(MakerTraits.EXPIRATION_MASK, expirationSec);
                return this;
            }
        },
        {
            key: "nonceOrEpoch",
            value: /**
     * Returns epoch in case `isEpochManagerEnabled()` and nonce otherwise
     */ function nonceOrEpoch() {
                return this.value.getMask(MakerTraits.NONCE_OR_EPOCH_MASK).value;
            }
        },
        {
            key: "withNonce",
            value: /**
     * Set nonce
     * Note: nonce and epoch share the same field, so they cant be set together
     * @param nonce must be less or equal to `uint40::max`
     */ function withNonce(nonce) {
                this.value = this.value.setMask(MakerTraits.NONCE_OR_EPOCH_MASK, nonce);
                return this;
            }
        },
        {
            key: "withEpoch",
            value: /**
     * Enable epoch manager check
     *
     * If set, the contract will check that order epoch equals to epoch on `SeriesEpochManager` contract
     * Note: epoch manager can be used only when `partialFills` AND `multipleFills` allowed
     * Note: nonce and epoch share the same field, so they cant be set together
     *
     * @param series subgroup for epoch
     * @param epoch unique order id inside series
     * @see https://github.com/1inch/limit-order-protocol/blob/23d655844191dea7960a186652307604a1ed480a/contracts/helpers/SeriesEpochManager.sol#L6
     */ function withEpoch(series, epoch) {
                this.setSeries(series);
                this.enableEpochManagerCheck();
                return this.withNonce(epoch);
            }
        },
        {
            key: "series",
            value: /**
     * Get current series
     */ function series() {
                return this.value.getMask(MakerTraits.SERIES_MASK).value;
            }
        },
        {
            key: "hasExtension",
            value: /**
     * Returns true if order has an extension and false otherwise
     */ function hasExtension() {
                return this.value.getBit(MakerTraits.HAS_EXTENSION_FLAG) === 1;
            }
        },
        {
            key: "withExtension",
            value: /**
     * Mark that order has an extension
     */ function withExtension() {
                this.value = this.value.setBit(MakerTraits.HAS_EXTENSION_FLAG, 1);
                return this;
            }
        },
        {
            key: "isPartialFillAllowed",
            value: /**
     * Is partial fills allowed for order
     */ function isPartialFillAllowed() {
                return this.value.getBit(MakerTraits.NO_PARTIAL_FILLS_FLAG) === 0;
            }
        },
        {
            key: "disablePartialFills",
            value: /**
     * Disable partial fills for order
     */ function disablePartialFills() {
                this.value = this.value.setBit(MakerTraits.NO_PARTIAL_FILLS_FLAG, 1);
                return this;
            }
        },
        {
            key: "allowPartialFills",
            value: /**
     * Allow partial fills for order
     */ function allowPartialFills() {
                this.value = this.value.setBit(MakerTraits.NO_PARTIAL_FILLS_FLAG, 0);
                return this;
            }
        },
        {
            key: "setPartialFills",
            value: /**
     * Set partial fill flag to passed value
     */ function setPartialFills(val) {
                return val ? this.allowPartialFills() : this.disablePartialFills();
            }
        },
        {
            key: "isMultipleFillsAllowed",
            value: /**
     * Returns true if order allowing more than one fill and false otherwise
     */ function isMultipleFillsAllowed() {
                return this.value.getBit(MakerTraits.ALLOW_MULTIPLE_FILLS_FLAG) === 1;
            }
        },
        {
            key: "allowMultipleFills",
            value: /**
     * Allow many fills for order
     */ function allowMultipleFills() {
                this.value = this.value.setBit(MakerTraits.ALLOW_MULTIPLE_FILLS_FLAG, 1);
                return this;
            }
        },
        {
            key: "disableMultipleFills",
            value: /**
     * Allow at max 1 fill for order
     */ function disableMultipleFills() {
                this.value = this.value.setBit(MakerTraits.ALLOW_MULTIPLE_FILLS_FLAG, 0);
                return this;
            }
        },
        {
            key: "setMultipleFills",
            value: /**
     * If `val` is true, then multiple fills allowed, otherwise disallowed
     */ function setMultipleFills(val) {
                return val ? this.allowMultipleFills() : this.disableMultipleFills();
            }
        },
        {
            key: "hasPreInteraction",
            value: /**
     * Returns true if maker has pre-interaction and false otherwise
     */ function hasPreInteraction() {
                return this.value.getBit(MakerTraits.PRE_INTERACTION_CALL_FLAG) === 1;
            }
        },
        {
            key: "enablePreInteraction",
            value: /**
     * Enable maker pre-interaction
     */ function enablePreInteraction() {
                this.value = this.value.setBit(MakerTraits.PRE_INTERACTION_CALL_FLAG, 1);
                return this;
            }
        },
        {
            key: "disablePreInteraction",
            value: /**
     * Disable maker pre-interaction
     */ function disablePreInteraction() {
                this.value = this.value.setBit(MakerTraits.PRE_INTERACTION_CALL_FLAG, 0);
                return this;
            }
        },
        {
            key: "hasPostInteraction",
            value: /**
     * Returns true if maker has post-interaction and false otherwise
     */ function hasPostInteraction() {
                return this.value.getBit(MakerTraits.POST_INTERACTION_CALL_FLAG) === 1;
            }
        },
        {
            key: "enablePostInteraction",
            value: /**
     * Enable maker post-interaction
     */ function enablePostInteraction() {
                this.value = this.value.setBit(MakerTraits.POST_INTERACTION_CALL_FLAG, 1);
                return this;
            }
        },
        {
            key: "disablePostInteraction",
            value: /**
     * Disable maker post-interaction
     */ function disablePostInteraction() {
                this.value = this.value.setBit(MakerTraits.POST_INTERACTION_CALL_FLAG, 0);
                return this;
            }
        },
        {
            key: "isEpochManagerEnabled",
            value: /**
     * Returns true if epoch manager enabled
     *
     * @see MakerTraits.enableEpochManagerCheck
     */ function isEpochManagerEnabled() {
                return this.value.getBit(MakerTraits.NEED_CHECK_EPOCH_MANAGER_FLAG) === 1;
            }
        },
        {
            key: "isPermit2",
            value: /**
     * Returns true if `permit2` enabled for maker funds transfer
     *
     * @see https://github.com/Uniswap/permit2
     */ function isPermit2() {
                return this.value.getBit(MakerTraits.USE_PERMIT2_FLAG) === 1;
            }
        },
        {
            key: "enablePermit2",
            value: /**
     * Use `permit2` to transfer maker funds to contract
     *
     * @see https://github.com/Uniswap/permit2
     */ function enablePermit2() {
                this.value = this.value.setBit(MakerTraits.USE_PERMIT2_FLAG, 1);
                return this;
            }
        },
        {
            key: "disablePermit2",
            value: /**
     * Do not use `permit2` to transfer maker funds to contract
     *
     * @see https://github.com/Uniswap/permit2
     */ function disablePermit2() {
                this.value = this.value.setBit(MakerTraits.USE_PERMIT2_FLAG, 0);
                return this;
            }
        },
        {
            key: "isNativeUnwrapEnabled",
            value: /**
     * Is WRAPPED token will be unwrapped to NATIVE before sending to maker
     */ function isNativeUnwrapEnabled() {
                return this.value.getBit(MakerTraits.UNWRAP_WETH_FLAG) === 1;
            }
        },
        {
            key: "enableNativeUnwrap",
            value: /**
     * Unwrap WRAPPED token to NATIVE before sending it to maker
     */ function enableNativeUnwrap() {
                this.value = this.value.setBit(MakerTraits.UNWRAP_WETH_FLAG, 1);
                return this;
            }
        },
        {
            key: "disableNativeUnwrap",
            value: /**
     * Do not unwrap WRAPPED token to NATIVE before sending it to maker
     */ function disableNativeUnwrap() {
                this.value = this.value.setBit(MakerTraits.UNWRAP_WETH_FLAG, 0);
                return this;
            }
        },
        {
            key: "asBigInt",
            value: function asBigInt() {
                return this.value.value;
            }
        },
        {
            key: "isBitInvalidatorMode",
            value: /**
     * Returns true if bit invalidator mode is used to invalidate order (cancel/mark as filled)
     *
     * Bit invalidator is cheaper in terms of gas, but can be used only when partial fills OR multiple fills are disabled
     *
     * @see https://github.com/1inch/limit-order-protocol/blob/3c9b8ab8bbc4c10ff8d615fc3d33f501993c292d/contracts/libraries/MakerTraitsLib.sol#L142
     */ function isBitInvalidatorMode() {
                return !this.isPartialFillAllowed() || !this.isMultipleFillsAllowed();
            }
        },
        {
            key: "enableEpochManagerCheck",
            value: function enableEpochManagerCheck() {
                assert(!this.isBitInvalidatorMode(), 'Epoch manager allowed only when partialFills and multipleFills enabled');
                this.value = this.value.setBit(MakerTraits.NEED_CHECK_EPOCH_MANAGER_FLAG, 1);
            }
        },
        {
            key: "setSeries",
            value: /**
     * Set series. Only when epoch manager enabled
     * Series is a subgroup for epoch's, it can be useful when you want to cancel a group of orders at once
     *
     * @see MakerTraits.enableEpochManagerCheck
     */ function setSeries(series) {
                this.value = this.value.setMask(MakerTraits.SERIES_MASK, series);
            }
        }
    ], [
        {
            key: "default",
            value: function _default() {
                return new MakerTraits(0n);
            }
        }
    ]);
    return MakerTraits;
}();
// Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series
_define_property(MakerTraits, "ALLOWED_SENDER_MASK", new BitMask(0n, 80n));
_define_property(MakerTraits, "EXPIRATION_MASK", new BitMask(80n, 120n));
_define_property(MakerTraits, "NONCE_OR_EPOCH_MASK", new BitMask(120n, 160n));
_define_property(MakerTraits, "SERIES_MASK", new BitMask(160n, 200n));
_define_property(MakerTraits, "NO_PARTIAL_FILLS_FLAG", 255n);
_define_property(MakerTraits, "ALLOW_MULTIPLE_FILLS_FLAG", 254n);
_define_property(MakerTraits, "PRE_INTERACTION_CALL_FLAG", 252n);
_define_property(MakerTraits, "POST_INTERACTION_CALL_FLAG", 251n);
_define_property(MakerTraits, "NEED_CHECK_EPOCH_MANAGER_FLAG", 250n);
_define_property(MakerTraits, "HAS_EXTENSION_FLAG", 249n);
_define_property(MakerTraits, "USE_PERMIT2_FLAG", 248n);
_define_property(MakerTraits, "UNWRAP_WETH_FLAG", 247n);
