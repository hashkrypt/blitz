"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "LimitOrder", {
    enumerable: true,
    get: function() {
        return LimitOrder;
    }
});
var _ethers = require("ethers");
var _byteutils = require("@1inch/byte-utils");
var _assert = /*#__PURE__*/ _interop_require_default(require("assert"));
var _index = require("./eip712/index.js");
var _makertraits = require("./maker-traits.js");
var _extension = require("./extensions/extension.js");
var _sourcetrack = require("./source-track.js");
var _address = require("../address.js");
var _randbigint = require("../utils/rand-bigint.js");
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var LimitOrder = /*#__PURE__*/ function() {
    "use strict";
    function LimitOrder(orderInfo) {
        var makerTraits = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new _makertraits.MakerTraits(0n), extension = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _extension.Extension.default();
        _class_call_check(this, LimitOrder);
        var _orderInfo_receiver;
        _define_property(this, "extension", void 0);
        _define_property(this, "maker", void 0);
        _define_property(this, "receiver", void 0);
        _define_property(this, "makerAsset", void 0);
        _define_property(this, "takerAsset", void 0);
        _define_property(this, "makingAmount", void 0);
        _define_property(this, "takingAmount", void 0);
        _define_property(this, "makerTraits", void 0);
        _define_property(this, "_salt", void 0);
        this.extension = extension;
        (0, _assert.default)(!orderInfo.takerAsset.isNative(), "".concat(orderInfo.takerAsset, " can not be 'takerAsset'. Use wrapper address as 'takerAsset' and 'makerTraits.enableNativeUnwrap' to swap to NATIVE currency"));
        (0, _assert.default)(!orderInfo.makerAsset.isNative(), 'Maker asset can not be NATIVE, use wrapper');
        this.makerAsset = orderInfo.makerAsset;
        this.takerAsset = orderInfo.takerAsset;
        this.makingAmount = orderInfo.makingAmount;
        this.takingAmount = orderInfo.takingAmount;
        this._salt = LimitOrder.verifySalt(orderInfo.salt || LimitOrder.buildSalt(extension), extension);
        this.maker = orderInfo.maker;
        this.receiver = ((_orderInfo_receiver = orderInfo.receiver) === null || _orderInfo_receiver === void 0 ? void 0 : _orderInfo_receiver.equal(orderInfo.maker)) ? _address.Address.ZERO_ADDRESS : orderInfo.receiver || _address.Address.ZERO_ADDRESS;
        this.makerTraits = makerTraits;
        (0, _assert.default)(this.makingAmount <= _byteutils.UINT_256_MAX, 'makingAmount too big');
        (0, _assert.default)(this.takingAmount <= _byteutils.UINT_256_MAX, 'takingAmount too big');
        if (!extension.isEmpty()) {
            this.makerTraits.withExtension();
        }
    }
    _create_class(LimitOrder, [
        {
            key: "salt",
            get: function get() {
                return this._salt;
            }
        },
        {
            key: "setSource",
            value: /**
     * Injects source info to order `salt` [224, 255] bits
     * check `getTrackCodeForSource` implementation for exact injected data
     *
     * @param source order source identifier
     * @see getTrackCodeForSource
     */ function setSource(source) {
                this._salt = (0, _sourcetrack.injectTrackCode)(this.salt, source);
                return this;
            }
        },
        {
            key: "toCalldata",
            value: function toCalldata() {
                return _ethers.AbiCoder.defaultAbiCoder().encode([
                    LimitOrder.Web3Type
                ], [
                    this.build()
                ]);
            }
        },
        {
            key: "build",
            value: function build() {
                var _this_makerTraits;
                return {
                    maker: this.maker.toString(),
                    makerAsset: this.makerAsset.toString(),
                    takerAsset: this.takerAsset.toString(),
                    makerTraits: (((_this_makerTraits = this.makerTraits) === null || _this_makerTraits === void 0 ? void 0 : _this_makerTraits.asBigInt()) || 0n).toString(),
                    salt: this.salt.toString(),
                    makingAmount: this.makingAmount.toString(),
                    takingAmount: this.takingAmount.toString(),
                    receiver: this.receiver.toString()
                };
            }
        },
        {
            key: "getTypedData",
            value: function getTypedData(chainId) {
                var domain = (0, _index.getLimitOrderV4Domain)(chainId);
                return (0, _index.buildOrderTypedData)(domain.chainId, domain.verifyingContract, domain.name, domain.version, this.build());
            }
        },
        {
            key: "getOrderHash",
            value: function getOrderHash(chainId) {
                return (0, _index.getOrderHash)(this.getTypedData(chainId));
            }
        },
        {
            key: "isPrivate",
            value: /**
     * Returns true if only a specific address can fill order
     */ function isPrivate() {
                return this.makerTraits.isPrivate();
            }
        }
    ], [
        {
            key: "buildSalt",
            value: /**
     * Build correct salt for order
     *
     * If order has extension - it is crucial to build correct salt
     * otherwise order won't be ever filled
     *
     * @see https://github.com/1inch/limit-order-protocol/blob/7bc5129ae19832338169ca21e4cf6331e8ff44f6/contracts/OrderLib.sol#L153
     *
     */ function buildSalt(extension) {
                var baseSalt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (0, _randbigint.randBigInt)((1n << 96n) - 1n);
                if (extension.isEmpty()) {
                    return baseSalt;
                }
                return baseSalt << 160n | extension.keccak256() & _byteutils.UINT_160_MAX;
            }
        },
        {
            key: "verifySalt",
            value: function verifySalt(salt, extension) {
                (0, _assert.default)(salt <= _byteutils.UINT_256_MAX, 'salt too big');
                if (extension.isEmpty()) {
                    return salt;
                }
                var hash = salt & _byteutils.UINT_160_MAX;
                var expectedHash = extension.keccak256() & _byteutils.UINT_160_MAX;
                (0, _assert.default)(hash === expectedHash, 'invalid salt: lowest 160 bits should be extension hash');
                return salt;
            }
        },
        {
            key: "fromCalldata",
            value: function fromCalldata(bytes) {
                (0, _assert.default)((0, _byteutils.isHexString)(bytes), 'Bytes should be valid hex string with 0x prefix');
                var info = _ethers.AbiCoder.defaultAbiCoder().decode([
                    LimitOrder.Web3Type
                ], bytes);
                var order = info[0];
                return new LimitOrder({
                    salt: order.salt ? BigInt(order.salt) : undefined,
                    maker: new _address.Address(order.maker),
                    receiver: new _address.Address(order.receiver),
                    takingAmount: BigInt(order.takingAmount),
                    makingAmount: BigInt(order.makingAmount),
                    takerAsset: new _address.Address(order.takerAsset),
                    makerAsset: new _address.Address(order.makerAsset)
                }, new _makertraits.MakerTraits(BigInt(order.makerTraits)));
            }
        },
        {
            key: "fromDataAndExtension",
            value: function fromDataAndExtension(data, extension) {
                return new LimitOrder({
                    salt: BigInt(data.salt),
                    maker: new _address.Address(data.maker),
                    receiver: new _address.Address(data.receiver),
                    takingAmount: BigInt(data.takingAmount),
                    makingAmount: BigInt(data.makingAmount),
                    takerAsset: new _address.Address(data.takerAsset),
                    makerAsset: new _address.Address(data.makerAsset)
                }, new _makertraits.MakerTraits(BigInt(data.makerTraits)), extension);
            }
        }
    ]);
    return LimitOrder;
}();
_define_property(LimitOrder, "Web3Type", "tuple(".concat([
    'uint256 salt',
    'address maker',
    'address receiver',
    'address makerAsset',
    'address takerAsset',
    'uint256 makingAmount',
    'uint256 takingAmount',
    'uint256 makerTraits'
], ")"));
