function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
import { Interface, Signature } from 'ethers';
import assert from 'assert';
import LOP_V4_ABI from '../abi/AggregationRouterV6.abi.json' with {
    type: 'json'
};
import { ZX } from '../constants.js';
var lopContract = new Interface(LOP_V4_ABI);
/**
 * @see https://github.com/1inch/limit-order-protocol/blob/3169ea46932ef44114a215a60d1d91ef022b416d/contracts/OrderMixin.sol#L27
 */ export var LimitOrderContract = /*#__PURE__*/ function() {
    "use strict";
    function LimitOrderContract() {
        _class_call_check(this, LimitOrderContract);
    }
    _create_class(LimitOrderContract, null, [
        {
            key: "getFillOrderCalldata",
            value: /**
     *  Fill order WITHOUT an extension and taker interaction
     *
     *  @see getFillOrderArgsCalldata
     *  @see getFillContractOrderCalldata
     */ function getFillOrderCalldata(order, signature, takerTraits, amount) {
                var _Signature_from = Signature.from(signature), r = _Signature_from.r, vs = _Signature_from.yParityAndS;
                var _takerTraits_encode = takerTraits.encode(), args = _takerTraits_encode.args, trait = _takerTraits_encode.trait;
                assert(args === ZX, 'takerTraits contains args data, use LimitOrderContract.getFillOrderArgsCalldata method');
                return lopContract.encodeFunctionData('fillOrder', [
                    order,
                    r,
                    vs,
                    amount,
                    trait
                ]);
            }
        },
        {
            key: "getFillContractOrderCalldata",
            value: /**
     *  Fill contract order (order maker is smart-contract) WITHOUT an extension and taker interaction
     *
     *  @see getFillContractOrderArgsCalldata
     *  @see getFillOrderCalldata
     */ function getFillContractOrderCalldata(order, signature, takerTraits, amount) {
                var _takerTraits_encode = takerTraits.encode(), args = _takerTraits_encode.args, trait = _takerTraits_encode.trait;
                assert(args === ZX, 'takerTraits contains args data, use LimitOrderContract.getFillContractOrderArgsCalldata method');
                return lopContract.encodeFunctionData('fillContractOrder', [
                    order,
                    signature,
                    amount,
                    trait,
                    args
                ]);
            }
        },
        {
            key: "getFillOrderArgsCalldata",
            value: /**
     *  Fill order WITH an extension or taker interaction
     *
     *  @see getFillOrderCalldata
     *  @see getFillContractOrderArgsCalldata
     */ function getFillOrderArgsCalldata(order, signature, takerTraits, amount) {
                var _Signature_from = Signature.from(signature), r = _Signature_from.r, vs = _Signature_from.yParityAndS;
                var _takerTraits_encode = takerTraits.encode(), args = _takerTraits_encode.args, trait = _takerTraits_encode.trait;
                return lopContract.encodeFunctionData('fillOrderArgs', [
                    order,
                    r,
                    vs,
                    amount,
                    trait,
                    args
                ]);
            }
        },
        {
            key: "getFillContractOrderArgsCalldata",
            value: /**
     *  Fill contract order (order maker is smart-contract) WITH an extension or taker interaction
     *
     *  @see getFillOrderArgsCalldata
     *  @see getFillContractOrderCalldata
     */ function getFillContractOrderArgsCalldata(order, signature, takerTraits, amount) {
                var _takerTraits_encode = takerTraits.encode(), args = _takerTraits_encode.args, trait = _takerTraits_encode.trait;
                return lopContract.encodeFunctionData('fillContractOrderArgs', [
                    order,
                    signature,
                    amount,
                    trait,
                    args
                ]);
            }
        }
    ]);
    return LimitOrderContract;
}();
